/**
 * Ê®°ÂºèÈÄâÊã©Âô® - Ë¥üË¥£WebSocketËøûÊé•ÁÆ°ÁêÜÂíåÊ®°ÂºèÂàáÊç¢
 * ÂÆûÁé∞‰∫ÜÂçï‰æãWebSocketËøûÊé•ÔºåÊîØÊåÅLANÂíåInternetÊ®°ÂºèÊó†ÁºùÂàáÊç¢
 */
class ModeSelector {
    constructor() {
        // Ê®°ÂºèÁä∂ÊÄÅ
        this.currentMode = 'lan';
        this.chatModeInstance = null;
        this.isInitialized = false;
        
        // WebSocketËøûÊé•Áä∂ÊÄÅ
        this.websocket = null;
        this.isWebSocketConnected = false;
        this.reconnectionAttempts = 0;
        this.currentServerIndex = 0;
        this.availableServers = [];
        this.heartbeatTimer = null;
        
        // Á≠âÂæÖDOMÂä†ËΩΩÂÆåÊàê
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.init());
        } else {
            this.init();
        }
    }
    
    async init() {
        this.initializeElements();
        this.bindEvents();
        
        // ÂÖàÂª∫Á´ãWebSocketËøûÊé•
        await this.connectToAvailableServer();
        
        // ÈªòËÆ§Âä†ËΩΩÂ±ÄÂüüÁΩëÊ®°Âºè
        await this.loadMode('lan');
        this.isInitialized = true;
    }
    
    /**
     * ÂàùÂßãÂåñDOMÂÖÉÁ¥†ÂºïÁî®
     */
    initializeElements() {
        this.elements = {
            lanModeButton: document.getElementById('lanMode'),
            internetModeButton: document.getElementById('internetMode'),
            internetRoomControls: document.getElementById('internetRoomControls'),
            lanStatus: document.getElementById('lanStatus')
        };
    }
    
    /**
     * ÁªëÂÆö‰∫ã‰ª∂ÁõëÂê¨Âô®
     */
    bindEvents() {
        this.elements.lanModeButton.addEventListener('click', () => this.switchMode('lan'));
        this.elements.internetModeButton.addEventListener('click', () => this.switchMode('internet'));
    }
    
    // WebSocketËøûÊé•ÁÆ°ÁêÜ
    async connectToAvailableServer() {
        try {
            if (!WS_CONFIG.servers || WS_CONFIG.servers.length === 0) {
                this.showNotification('‚ùå Ê≤°ÊúâÂèØÁî®ÁöÑÊúçÂä°Âô®ÈÖçÁΩÆ');
                return;
            }
            
            // Convert server URLs to objects with priority if needed
            this.availableServers = WS_CONFIG.servers.map((server, index) => {
                if (typeof server === 'string') {
                    return { url: server, priority: index + 1 };
                }
                return server;
            });
            this.tryNextServer();
        } catch (error) {
            console.error('Failed to load server list:', error);
            this.showNotification('‚ùå Âä†ËΩΩÊúçÂä°Âô®ÂàóË°®Â§±Ë¥•');
        }
    }
    
    tryNextServer() {
        if (this.currentServerIndex >= this.availableServers.length) {
            this.showNotification('‚ùå ÊâÄÊúâÊúçÂä°Âô®ÈÉΩ‰∏çÂèØÁî®');
            this.currentServerIndex = 0;
            return;
        }
        
        const server = this.availableServers[this.currentServerIndex];
        const serverUrl = server.url;
        console.log(`Trying server ${this.currentServerIndex + 1}/${this.availableServers.length}: ${server.name || serverUrl}`);
        this.showNotification(`üîÑ ËøûÊé•Âà∞ ${server.name || 'ÊúçÂä°Âô®'}...`);
        this.connectWebSocket(serverUrl);
    }
    
    connectWebSocket(serverUrl) {
        try {
            this.websocket = new WebSocket(serverUrl || WS_CONFIG.url);
            
            this.websocket.onopen = () => {
                console.log('WebSocket connected to:', serverUrl || WS_CONFIG.url);
                this.isWebSocketConnected = true;
                this.reconnectionAttempts = 0;
                this.currentServerIndex = 0;
                this.showNotification('‚úÖ Â∑≤ËøûÊé•Âà∞‰ø°‰ª§ÊúçÂä°Âô®');
                this.startHeartbeat();
                
                // ÈÄöÁü•ÂΩìÂâçÊ®°ÂºèWebSocketÂ∑≤ËøûÊé•
                if (this.chatModeInstance && this.chatModeInstance.onWebSocketConnected) {
                    this.chatModeInstance.onWebSocketConnected();
                }
            };
            
            this.websocket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                // Â∞ÜÊ∂àÊÅØËΩ¨ÂèëÁªôÂΩìÂâçÊ®°ÂºèÂ§ÑÁêÜ
                if (this.chatModeInstance && this.chatModeInstance.handleWebSocketMessage) {
                    this.chatModeInstance.handleWebSocketMessage(message);
                }
            };
            
            this.websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                this.showNotification('‚ùå ËøûÊé•ÈîôËØØÔºåÂ∞ùËØï‰∏ã‰∏Ä‰∏™ÊúçÂä°Âô®...');
                
                this.currentServerIndex++;
                setTimeout(() => this.tryNextServer(), WS_CONFIG.serverSwitchDelay);
            };
            
            this.websocket.onclose = () => {
                console.log('WebSocket disconnected');
                this.isWebSocketConnected = false;
                this.stopHeartbeat();
                
                // ÈÄöÁü•ÂΩìÂâçÊ®°ÂºèWebSocketÂ∑≤Êñ≠ÂºÄ
                if (this.chatModeInstance && this.chatModeInstance.onWebSocketDisconnected) {
                    this.chatModeInstance.onWebSocketDisconnected();
                }
                
                if (this.reconnectionAttempts < WS_CONFIG.maxReconnectAttempts) {
                    this.showNotification(`üîÑ ÈáçËøû‰∏≠... (${this.reconnectionAttempts + 1}/${WS_CONFIG.maxReconnectAttempts})`);
                    setTimeout(() => {
                        this.reconnectionAttempts++;
                        this.connectWebSocket(serverUrl);
                    }, WS_CONFIG.reconnectDelay);
                } else {
                    this.reconnectionAttempts = 0;
                    this.currentServerIndex++;
                    this.showNotification('‚ö†Ô∏è ËøûÊé•Â§±Ë¥•ÔºåÂ∞ùËØï‰∏ã‰∏Ä‰∏™ÊúçÂä°Âô®...');
                    setTimeout(() => this.tryNextServer(), WS_CONFIG.serverSwitchDelay);
                }
            };
        } catch (error) {
            console.error('Failed to connect WebSocket:', error);
        }
    }
    
    /**
     * ÂèëÈÄÅWebSocketÊ∂àÊÅØ
     * @param {Object} data - Ë¶ÅÂèëÈÄÅÁöÑÊï∞ÊçÆ
     */
    sendWebSocketMessage(data) {
        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
            this.websocket.send(JSON.stringify(data));
        } else {
            console.error('WebSocket is not connected');
        }
    }
    
    /**
     * ÂêØÂä®ÂøÉË∑≥Ê£ÄÊµã
     */
    startHeartbeat() {
        this.heartbeatTimer = setInterval(() => {
            if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                this.websocket.send(JSON.stringify({ type: 'heartbeat' }));
            }
        }, 30000);
    }
    
    /**
     * ÂÅúÊ≠¢ÂøÉË∑≥Ê£ÄÊµã
     */
    stopHeartbeat() {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
    }
    
    // Ê®°ÂºèÁÆ°ÁêÜ
    async loadMode(mode) {
        try {
            // Ê∏ÖÁêÜÂΩìÂâçÊ®°ÂºèÁä∂ÊÄÅÔºà‰ΩÜ‰∏çÊñ≠ÂºÄWebSocketÔºâ
            if (this.chatModeInstance) {
                this.cleanupMode();
            }
            
            // Êõ¥Êñ∞UI
            this.updateUI(mode);
            
            // Âä®ÊÄÅÂä†ËΩΩÂØπÂ∫îÁöÑËÑöÊú¨
            if (mode === 'lan') {
                if (!window.LANMode) {
                    await this.loadScript('assets/lan.js');
                }
                    // ÂàõÂª∫ÂÆû‰æãÊó∂‰º†ÂÖ•ÂèëÈÄÅÊ∂àÊÅØÁöÑÊñπÊ≥ï
                this.chatModeInstance = new window.LANMode(
                    (data) => this.sendWebSocketMessage(data),
                    this.isWebSocketConnected
                );
            } else {
                if (!window.InternetMode) {
                    await this.loadScript('assets/net.js');
                }
                this.chatModeInstance = new window.InternetMode(
                    (data) => this.sendWebSocketMessage(data),
                    this.isWebSocketConnected
                );
            }
            
            // Â¶ÇÊûúWebSocketÂ∑≤ËøûÊé•ÔºåÈÄöÁü•Êñ∞Ê®°Âºè
            if (this.isWebSocketConnected && this.chatModeInstance.onWebSocketConnected) {
                this.chatModeInstance.onWebSocketConnected();
            }
            
            this.currentMode = mode;
            console.log(`Loaded ${mode} mode`);
            
        } catch (error) {
            console.error(`Failed to load ${mode} mode:`, error);
            this.showNotification(`‚ùå Âä†ËΩΩ${mode === 'lan' ? 'Â±ÄÂüüÁΩë' : 'ÂÖ¨ÁΩë'}Ê®°ÂºèÂ§±Ë¥•`);
        }
    }
    
    loadScript(src) {
        return new Promise((resolve, reject) => {
            const existing = document.querySelector(`script[src="${src}"]`);
            if (existing) {
                resolve();
                return;
            }
            
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    switchMode(mode) {
        if (mode === this.currentMode) return;
        
        this.showNotification(`ÂàáÊç¢Âà∞${mode === 'lan' ? 'Â±ÄÂüüÁΩë' : 'ÂÖ¨ÁΩë'}Ê®°Âºè...`);
        this.loadMode(mode);
    }
    
    /**
     * Ê∏ÖÁêÜÂΩìÂâçÊ®°ÂºèÂÆû‰æã
     */
    cleanupMode() {
        if (!this.chatModeInstance) return;
        
        // Ë∞ÉÁî®Ê®°ÂºèÁöÑÊ∏ÖÁêÜÊñπÊ≥ï
        if (this.chatModeInstance.cleanup) {
            this.chatModeInstance.cleanup();
        }
        
        this.chatModeInstance = null;
    }
    
    updateUI(mode) {
        // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
        document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
        
        if (mode === 'lan') {
            this.elements.lanModeButton.classList.add('active');
            this.elements.lanStatus.style.display = 'block';
            this.elements.internetRoomControls.style.display = 'none';
            
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.placeholder = 'Ê£ÄÊµãÂà∞ÂêåÁΩëÊÆµÁî®Êà∑ÂêéÂç≥ÂèØÂºÄÂßãËÅäÂ§©...';
            }
        } else {
            this.elements.internetModeButton.classList.add('active');
            this.elements.lanStatus.style.display = 'none';
            this.elements.internetRoomControls.style.display = 'flex';
            
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.placeholder = 'Âä†ÂÖ•ÊàøÈó¥ÂêéÂç≥ÂèØÂºÄÂßãËÅäÂ§©...';
            }
        }
        
        // Ê∏ÖÁ©∫ËÅäÂ§©ËÆ∞ÂΩï
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
            chatMessages.innerHTML = '';
        }
        
        // Ê∏ÖÁ©∫Áî®Êà∑ÂàóË°®
        const userListContainer = document.getElementById('userListContainer');
        if (userListContainer) {
            userListContainer.innerHTML = '';
        }
    }
    
    showNotification(text) {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = text;
        
        const existingNotifications = document.querySelectorAll('.notification:not(.notification-exit)');
        const offset = existingNotifications.length * 60;
        notification.style.top = `${20 + offset}px`;
        
        document.body.appendChild(notification);
        
        setTimeout(() => notification.classList.add('notification-show'), 10);
        
        setTimeout(() => {
            notification.classList.add('notification-exit');
            setTimeout(() => notification.remove(), 500);
        }, 3000);
    }
}

/**
 * Âü∫Á°ÄËÅäÂ§©Ê®°ÂºèÁ±ª - ÂåÖÂê´ÊâÄÊúâÊ®°ÂºèÂÖ±‰∫´ÁöÑÂäüËÉΩ
 */
class BaseChatMode {
    constructor(sendWebSocketMessage, isWebSocketConnected) {
        this.sendWebSocketMessage = sendWebSocketMessage;
        this.isWebSocketConnected = isWebSocketConnected;
        
        // P2P ËøûÊé•ÁÆ°ÁêÜ
        this.peerConnections = new Map();
        this.currentRoomId = null;
        this.currentUserId = null;
        this.currentUserInfo = null;
        this.roomUsers = new Map();
    }

    // ÂÖ±‰∫´ÁöÑDOMÂÖÉÁ¥†ÂàùÂßãÂåñ
    initializeSharedElements() {
        return {
            messageInput: document.getElementById('messageInput'),
            sendButton: document.getElementById('sendBtn'),
            chatMessages: document.getElementById('chatMessages'),
            connectionStatus: document.getElementById('connectionStatus'),
            fileInput: document.getElementById('fileInput'),
            attachButton: document.getElementById('attachBtn')
        };
    }

    // ÂÖ±‰∫´ÁöÑ‰∫ã‰ª∂ÁªëÂÆö
    bindSharedEvents() {
        this.domElements.sendButton.addEventListener('click', () => this.sendChatMessage());
        this.domElements.messageInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') this.sendChatMessage();
        });
        
        // Êñá‰ª∂Áõ∏ÂÖ≥‰∫ã‰ª∂
        this.domElements.attachButton.addEventListener('click', () => {
            this.domElements.fileInput.click();
        });
        
        this.domElements.fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                this.handleFileSelection(file);
            }
        });
    }

    // WebSocketËøûÊé•ÁÆ°ÁêÜ
    onWebSocketConnected() {
        this.isWebSocketConnected = true;
        this.updateConnectionStatus('connected');
    }

    onWebSocketDisconnected() {
        this.isWebSocketConnected = false;
        this.updateConnectionStatus('disconnected');
        this.closePeerConnections();
    }

    // WebSocketÊ∂àÊÅØÂ§ÑÁêÜ
    handleWebSocketMessage(message) {
        switch (message.type) {
            case 'joined':
                this.currentUserId = message.userId;
                this.currentUserInfo = message.userInfo || this.generateUserInfo();
                this.handleJoinedRoom(message);
                break;
            case 'user-joined':
                this.handleUserJoined(message);
                break;
            case 'user-left':
                this.handleUserLeft(message);
                break;
            case 'user-list':
                this.updateUserList(message.users);
                break;
            case 'offer':
                this.handleOffer(message);
                break;
            case 'answer':
                this.handleAnswer(message);
                break;
            case 'ice-candidate':
                this.handleIceCandidate(message);
                break;
            case 'heartbeat-ack':
                break;
        }
    }

    // Áî®Êà∑ÁÆ°ÁêÜ
    handleUserJoined(data) {
        if (data.userInfo) {
            this.roomUsers.set(data.userId, data.userInfo);
        }
        
        const userInfo = this.roomUsers.get(data.userId);
        const userName = userInfo ? userInfo.name : 'Áî®Êà∑';
        this.showNotification(`üëã ${userName} Âä†ÂÖ•‰∫ÜÊàøÈó¥`);
        this.updateUserList();
        
        if (data.userId !== this.currentUserId) {
            this.createPeerConnection(data.userId, false);
        }
    }

    handleUserLeft(data) {
        const userInfo = this.roomUsers.get(data.userId);
        const userName = userInfo ? userInfo.name : 'Áî®Êà∑';
        this.showNotification(`üëã ${userName} Á¶ªÂºÄ‰∫ÜÊàøÈó¥`);
        
        this.roomUsers.delete(data.userId);
        this.updateUserList();
        
        if (this.peerConnections.has(data.userId)) {
            const peerData = this.peerConnections.get(data.userId);
            peerData.pc.close();
            this.peerConnections.delete(data.userId);
        }
    }

    // P2PËøûÊé•ÁÆ°ÁêÜ
    createPeerConnection(peerId, createOffer) {
        console.log(`Creating peer connection with ${this.formatUserId(peerId)}, createOffer: ${createOffer}`);
        const pc = new RTCPeerConnection(RTC_CONFIG);
        const peerData = { pc, dataChannel: null };
        this.peerConnections.set(peerId, peerData);
        
        pc.onconnectionstatechange = () => {
            console.log(`Connection state with ${this.formatUserId(peerId)}: ${pc.connectionState}`);
            if (pc.connectionState === 'connected') {
                this.showNotification(`‚úÖ Â∑≤‰∏éÁî®Êà∑Âª∫Á´ãP2PËøûÊé•`);
            } else if (pc.connectionState === 'failed') {
                this.showNotification(`‚ùå ‰∏éÁî®Êà∑ÁöÑP2PËøûÊé•Â§±Ë¥•`);
            }
        };
        
        if (createOffer) {
            const dataChannel = pc.createDataChannel('chat');
            peerData.dataChannel = dataChannel;
            this.setupDataChannel(dataChannel, peerId);
        }
        
        pc.onicecandidate = (event) => {
            if (event.candidate) {
                console.log(`Sending ICE candidate to ${this.formatUserId(peerId)}`);
                this.sendWebSocketMessage({
                    type: 'ice-candidate',
                    target: peerId,
                    data: event.candidate
                });
            }
        };
        
        pc.ondatachannel = (event) => {
            console.log(`Received data channel from ${this.formatUserId(peerId)}`);
            peerData.dataChannel = event.channel;
            this.setupDataChannel(event.channel, peerId);
        };
        
        if (createOffer) {
            pc.createOffer().then(offer => {
                console.log(`Creating offer for ${this.formatUserId(peerId)}`);
                pc.setLocalDescription(offer);
                this.sendWebSocketMessage({
                    type: 'offer',
                    target: peerId,
                    data: offer
                });
            }).catch(error => {
                console.error(`Failed to create offer for ${this.formatUserId(peerId)}:`, error);
            });
        }
        
        return pc;
    }

    setupDataChannel(dataChannel, peerId) {
        dataChannel.onopen = () => {
            console.log(`Data channel opened with ${this.formatUserId(peerId)}`);
            this.showNotification(`üí¨ Êï∞ÊçÆÈÄöÈÅìÂ∑≤Âª∫Á´ãÔºåÂèØ‰ª•ÂºÄÂßãËÅäÂ§©`);
            this.updateChannelStatus();
            this.renderUserList();
        };
        
        dataChannel.onmessage = (event) => {
            const message = JSON.parse(event.data);
            
            // Â§ÑÁêÜ‰∏çÂêåÁ±ªÂûãÁöÑÊ∂àÊÅØ
            switch (message.type) {
                case 'file-metadata':
                    this.handleFileMetadata(message, peerId);
                    break;
                case 'file-chunk':
                    this.handleFileChunk(message, peerId);
                    break;
                default:
                    // ÊôÆÈÄöÊñáÊú¨Ê∂àÊÅØ
                    this.displayMessage(message, false);
                    break;
            }
        };
        
        dataChannel.onerror = (error) => {
            console.error(`Data channel error with ${this.formatUserId(peerId)}:`, error);
            this.showNotification(`‚ö†Ô∏è Êï∞ÊçÆÈÄöÈÅìÈîôËØØ`);
        };
        
        dataChannel.onclose = () => {
            console.log(`Data channel closed with ${this.formatUserId(peerId)}`);
            this.updateChannelStatus();
            this.renderUserList();
        };
    }

    updateChannelStatus() {
        this.renderUserList();
    }

    handleOffer(data) {
        const pc = this.createPeerConnection(data.from, false);
        
        pc.setRemoteDescription(new RTCSessionDescription(data.data))
            .then(() => pc.createAnswer())
            .then(answer => {
                pc.setLocalDescription(answer);
                this.sendWebSocketMessage({
                    type: 'answer',
                    target: data.from,
                    data: answer
                });
            });
    }

    handleAnswer(data) {
        const peerData = this.peerConnections.get(data.from);
        if (peerData) {
            peerData.pc.setRemoteDescription(new RTCSessionDescription(data.data));
        }
    }

    handleIceCandidate(data) {
        const peerData = this.peerConnections.get(data.from);
        if (peerData) {
            peerData.pc.addIceCandidate(new RTCIceCandidate(data.data));
        }
    }

    // Ê∂àÊÅØÂäüËÉΩ
    sendChatMessage() {
        const message = this.domElements.messageInput.value.trim();
        if (!message) return;
        
        const messageData = {
            text: message,
            userId: this.currentUserId,
            userInfo: this.currentUserInfo,
            timestamp: Date.now()
        };
        
        let sentToAnyPeer = false;
        this.peerConnections.forEach((peerData) => {
            if (peerData.dataChannel && peerData.dataChannel.readyState === 'open') {
                peerData.dataChannel.send(JSON.stringify(messageData));
                sentToAnyPeer = true;
            }
        });
        
        this.displayMessage(messageData, true);
        this.domElements.messageInput.value = '';
        
        if (!sentToAnyPeer && this.roomUsers.size <= 1) {
            this.showNotification('üí° ÂΩìÂâçÂè™ÊúâÊÇ®Âú®ÊàøÈó¥‰∏≠');
        }
    }
    
    // Êñá‰ª∂Â§ÑÁêÜÁõ∏ÂÖ≥ÊñπÊ≥ï
    handleFileSelection(file) {
        // ÈôêÂà∂Êñá‰ª∂Â§ßÂ∞èÔºà10MBÔºâ
        const maxSize = 10 * 1024 * 1024;
        if (file.size > maxSize) {
            this.showNotification('‚ùå Êñá‰ª∂Â§ßÂ∞è‰∏çËÉΩË∂ÖËøá10MB');
            return;
        }
        
        // Âè™Êé•ÂèóÂõæÁâáÊñá‰ª∂
        if (!file.type.startsWith('image/')) {
            this.showNotification('‚ùå ÁõÆÂâçÂè™ÊîØÊåÅÂèëÈÄÅÂõæÁâáÊñá‰ª∂');
            return;
        }
        
        // ËØªÂèñÊñá‰ª∂Âπ∂ÂèëÈÄÅ
        const reader = new FileReader();
        reader.onload = (e) => {
            const fileData = {
                type: 'file',
                fileType: file.type,
                fileName: file.name,
                fileSize: file.size,
                data: e.target.result,
                userId: this.currentUserId,
                userInfo: this.currentUserInfo,
                timestamp: Date.now()
            };
            
            this.sendFileData(fileData);
        };
        
        reader.readAsDataURL(file);
        this.domElements.fileInput.value = ''; // Ê∏ÖÁ©∫Êñá‰ª∂ÈÄâÊã©
    }
    
    sendFileData(fileData) {
        let sentToAnyPeer = false;
        const chunkSize = 16 * 1024; // 16KB chunks
        const totalChunks = Math.ceil(fileData.data.length / chunkSize);
        
        // ÂèëÈÄÅÊñá‰ª∂ÂÖÉÊï∞ÊçÆ
        const metadata = {
            type: 'file-metadata',
            fileId: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            fileName: fileData.fileName,
            fileType: fileData.fileType,
            fileSize: fileData.fileSize,
            totalChunks: totalChunks,
            userId: fileData.userId,
            userInfo: fileData.userInfo,
            timestamp: fileData.timestamp
        };
        
        this.peerConnections.forEach((peerData) => {
            if (peerData.dataChannel && peerData.dataChannel.readyState === 'open') {
                // ÂèëÈÄÅÂÖÉÊï∞ÊçÆ
                peerData.dataChannel.send(JSON.stringify(metadata));
                
                // ÂàÜÂùóÂèëÈÄÅÊñá‰ª∂Êï∞ÊçÆ
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, fileData.data.length);
                    const chunk = fileData.data.slice(start, end);
                    
                    const chunkData = {
                        type: 'file-chunk',
                        fileId: metadata.fileId,
                        chunkIndex: i,
                        totalChunks: totalChunks,
                        data: chunk
                    };
                    
                    setTimeout(() => {
                        if (peerData.dataChannel && peerData.dataChannel.readyState === 'open') {
                            peerData.dataChannel.send(JSON.stringify(chunkData));
                        }
                    }, i * 50); // Âª∂ËøüÂèëÈÄÅÔºåÈÅøÂÖçÊã•Â°û
                }
                
                sentToAnyPeer = true;
            }
        });
        
        // ÊòæÁ§∫ÂèëÈÄÅËøõÂ∫¶
        if (sentToAnyPeer) {
            this.showNotification(`üì§ Ê≠£Âú®ÂèëÈÄÅÂõæÁâá: ${fileData.fileName}`);
        }
        
        // ÊòæÁ§∫Ëá™Â∑±ÂèëÈÄÅÁöÑÂõæÁâá
        this.displayImage({
            ...metadata,
            data: fileData.data
        }, true);
        
        if (!sentToAnyPeer && this.roomUsers.size <= 1) {
            this.showNotification('üí° ÂΩìÂâçÂè™ÊúâÊÇ®Âú®ÊàøÈó¥‰∏≠');
        }
    }

    displayMessage(data, isOwn) {
        const messageWrapper = document.createElement('div');
        messageWrapper.className = `message-wrapper ${isOwn ? 'own' : 'other'}`;
        
        const messageHeader = document.createElement('div');
        messageHeader.className = 'message-header';
        
        const avatar = document.createElement('img');
        avatar.className = 'message-avatar';
        avatar.src = data.userInfo.avatar;
        avatar.alt = data.userInfo.name;
        
        const headerText = document.createElement('div');
        headerText.className = 'message-header-text';
        
        const name = document.createElement('span');
        name.className = 'message-name';
        name.textContent = data.userInfo.name;
        
        const time = document.createElement('span');
        time.className = 'message-time';
        time.textContent = new Date(data.timestamp).toLocaleTimeString();
        
        headerText.appendChild(name);
        headerText.appendChild(time);
        
        messageHeader.appendChild(avatar);
        messageHeader.appendChild(headerText);
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${isOwn ? 'message-own' : 'message-other'}`;
        
        const messageText = document.createElement('p');
        messageText.className = 'message-text';
        messageText.innerHTML = this.escapeHtml(data.text);
        
        messageDiv.appendChild(messageText);
        
        messageWrapper.appendChild(messageHeader);
        messageWrapper.appendChild(messageDiv);
        
        this.domElements.chatMessages.appendChild(messageWrapper);
        this.domElements.chatMessages.scrollTop = this.domElements.chatMessages.scrollHeight;
    }
    
    // Êñá‰ª∂Êé•Êî∂Áõ∏ÂÖ≥
    fileReceivers = new Map(); // Â≠òÂÇ®Ê≠£Âú®Êé•Êî∂ÁöÑÊñá‰ª∂
    
    handleFileMetadata(metadata, peerId) {
        // ÂàùÂßãÂåñÊñá‰ª∂Êé•Êî∂Âô®
        this.fileReceivers.set(metadata.fileId, {
            metadata: metadata,
            chunks: new Array(metadata.totalChunks),
            receivedChunks: 0,
            progressElement: null
        });
        
        // ÊòæÁ§∫Êñá‰ª∂Êé•Êî∂ËøõÂ∫¶
        this.showFileProgress(metadata.fileId, metadata.fileName, 0);
        console.log(`ÂºÄÂßãÊé•Êî∂Êñá‰ª∂: ${metadata.fileName} (${metadata.totalChunks} Âùó)`);
    }
    
    handleFileChunk(chunkData, peerId) {
        const receiver = this.fileReceivers.get(chunkData.fileId);
        if (!receiver) {
            console.error('Êî∂Âà∞Êú™Áü•Êñá‰ª∂ÁöÑÊï∞ÊçÆÂùó:', chunkData.fileId);
            return;
        }
        
        // Â≠òÂÇ®Êï∞ÊçÆÂùó
        receiver.chunks[chunkData.chunkIndex] = chunkData.data;
        receiver.receivedChunks++;
        
        // Êõ¥Êñ∞ËøõÂ∫¶
        const progress = (receiver.receivedChunks / receiver.metadata.totalChunks) * 100;
        this.updateFileProgress(chunkData.fileId, progress);
        
        // Ê£ÄÊü•ÊòØÂê¶Êé•Êî∂ÂÆåÊàê
        if (receiver.receivedChunks === receiver.metadata.totalChunks) {
            // ÈáçÁªÑÊñá‰ª∂
            const completeData = receiver.chunks.join('');
            
            // ÁßªÈô§ËøõÂ∫¶Êù°
            this.removeFileProgress(chunkData.fileId);
            
            // ÊòæÁ§∫ÂõæÁâá
            this.displayImage({
                ...receiver.metadata,
                data: completeData
            }, false);
            
            // Ê∏ÖÁêÜÊé•Êî∂Âô®
            this.fileReceivers.delete(chunkData.fileId);
        }
    }
    
    displayImage(imageData, isOwn) {
        const messageWrapper = document.createElement('div');
        messageWrapper.className = `message-wrapper ${isOwn ? 'own' : 'other'}`;
        
        const messageHeader = document.createElement('div');
        messageHeader.className = 'message-header';
        
        const avatar = document.createElement('img');
        avatar.className = 'user-avatar';
        avatar.src = imageData.userInfo.avatar;
        avatar.alt = imageData.userInfo.name;
        
        const headerText = document.createElement('div');
        headerText.className = 'message-header-text';
        
        const name = document.createElement('span');
        name.className = 'message-name';
        name.textContent = imageData.userInfo.name;
        
        const time = document.createElement('span');
        time.className = 'message-time';
        time.textContent = new Date(imageData.timestamp).toLocaleTimeString();
        
        headerText.appendChild(name);
        headerText.appendChild(time);
        
        messageHeader.appendChild(avatar);
        messageHeader.appendChild(headerText);
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${isOwn ? 'message-own' : 'message-other'}`;
        
        const img = document.createElement('img');
        img.src = imageData.data;
        img.alt = imageData.fileName;
        img.style.maxWidth = '300px';
        img.style.maxHeight = '300px';
        img.style.borderRadius = '8px';
        img.style.cursor = 'pointer';
        
        // ÁÇπÂáªÂõæÁâáÊü•ÁúãÂ§ßÂõæ
        img.onclick = () => {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                cursor: pointer;
            `;
            
            const fullImg = document.createElement('img');
            fullImg.src = imageData.data;
            fullImg.style.maxWidth = '90%';
            fullImg.style.maxHeight = '90%';
            fullImg.style.objectFit = 'contain';
            
            modal.appendChild(fullImg);
            modal.onclick = () => modal.remove();
            document.body.appendChild(modal);
        };
        
        messageDiv.appendChild(img);
        
        messageWrapper.appendChild(messageHeader);
        messageWrapper.appendChild(messageDiv);
        
        this.domElements.chatMessages.appendChild(messageWrapper);
        this.domElements.chatMessages.scrollTop = this.domElements.chatMessages.scrollHeight;
    }

    // Â∑•ÂÖ∑ÊñπÊ≥ï
    generateUserInfo() {
        const names = [
            'Â≠ôÊÇüÁ©∫', 'ÂîêÂÉß', 'Áå™ÂÖ´Êàí', 'Ê≤ôÂÉß', 'ÁôΩÈæôÈ©¨', 'ËßÇÈü≥Ëè©Ëê®', 'Â¶ÇÊù•‰ΩõÁ•ñ', 'ÁéâÁöáÂ§ßÂ∏ù', 'Â§™ÁôΩÈáëÊòü', 'Âì™Âêí',
            'Ë¥æÂÆùÁéâ', 'ÊûóÈªõÁéâ', 'ËñõÂÆùÈíó', 'ÁéãÁÜôÂá§', 'Ë¥æÊØç', 'ÂàòÂß•Âß•', 'Âè≤Êπò‰∫ë', 'Â¶ôÁéâ', 'Êô¥ÈõØ', 'Ë¢≠‰∫∫',
            'ÂàòÂ§á', 'ÂÖ≥ÁæΩ', 'Âº†È£û', 'ËØ∏Ëëõ‰∫Æ', 'ÊõπÊìç', 'Ëµµ‰∫ë', 'ÂêïÂ∏É', 'Ë≤ÇËùâ', 'Âë®Áëú', 'Â∞è‰πî',
            'ÂÆãÊ±ü', 'ÊûóÂÜ≤', 'Ê≠¶Êùæ', 'È≤ÅÊô∫Ê∑±', 'ÊùéÈÄµ', 'ÁáïÈùí', 'ÊΩòÈáëËé≤', 'Â≠ô‰∫åÂ®ò', 'Êâà‰∏âÂ®ò', 'Êó∂ËøÅ'
        ];
        
        const name = names[Math.floor(Math.random() * names.length)];
        const seed = Math.random().toString(36).substring(2, 15);
        const avatar = `https://api.dicebear.com/7.x/adventurer/svg?seed=${seed}`;
        
        return { name, avatar };
    }

    formatUserId(userId) {
        if (!userId) return 'user_unknown';
        const shortId = userId.substring(0, 8).toLowerCase();
        return `user_${shortId}`;
    }

    updateUserList(usersList) {
        if (usersList) {
            this.roomUsers.clear();
            for (const [userId, userInfo] of Object.entries(usersList)) {
                this.roomUsers.set(userId, userInfo);
            }
        }
        
        this.renderUserList();
        
        if (this.isWebSocketConnected) {
            this.updateConnectionStatus('connected');
        }
    }

    renderUserList() {
        let userListContainer = document.getElementById('userListContainer');
        if (!userListContainer) {
            userListContainer = document.createElement('div');
            userListContainer.id = 'userListContainer';
            userListContainer.className = 'user-list-container';
            
            const roomSection = document.querySelector('.room-section');
            roomSection.appendChild(userListContainer);
        }
        
        const allUsers = Array.from(this.roomUsers.entries());
        const myself = allUsers.find(([userId]) => userId === this.currentUserId);
        const otherUsers = allUsers.filter(([userId]) => userId !== this.currentUserId);
        
        const sortedUsers = myself ? [myself, ...otherUsers] : otherUsers;
        
        const userItems = sortedUsers.map(([userId, userInfo]) => {
            const isConnected = this.peerConnections.has(userId) && 
                               this.peerConnections.get(userId).dataChannel && 
                               this.peerConnections.get(userId).dataChannel.readyState === 'open';
            const isSelf = userId === this.currentUserId;
            
            let selfStatus = '';
            if (isSelf) {
                let hasAnyConnection = false;
                this.peerConnections.forEach((peerData) => {
                    if (peerData.dataChannel && peerData.dataChannel.readyState === 'open') {
                        hasAnyConnection = true;
                    }
                });
                selfStatus = hasAnyConnection ? 'connected' : 'pending';
            }
            
            const statusDot = `<span class="status-dot ${isSelf ? selfStatus : (isConnected ? 'connected' : 'pending')}"></span>`;
            
            return `
                <div class="user-item ${isSelf ? 'user-self' : ''}">
                    ${statusDot}
                    <img class="user-avatar-small" src="${userInfo.avatar}" alt="${userInfo.name}">
                    <span class="user-name">${userInfo.name}${isSelf ? ' (Êàë)' : ''}</span>
                </div>
            `;
        }).join('');
        
        userListContainer.innerHTML = `<div class="user-list">${userItems}</div>`;
    }

    closePeerConnections() {
        this.peerConnections.forEach((peerData) => {
            peerData.pc.close();
        });
        this.peerConnections.clear();
        this.renderUserList();
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Êñá‰ª∂ËøõÂ∫¶ÊòæÁ§∫ÊñπÊ≥ï
    showFileProgress(fileId, fileName, progress = 0) {
        const progressWrapper = document.createElement('div');
        progressWrapper.className = 'message-wrapper other';
        progressWrapper.id = `progress-${fileId}`;
        
        const progressDiv = document.createElement('div');
        progressDiv.className = 'file-progress';
        
        const progressText = document.createElement('div');
        progressText.className = 'file-progress-text';
        progressText.innerHTML = `
            <span>Êé•Êî∂Êñá‰ª∂: ${fileName}</span>
            <span class="progress-percent">${Math.round(progress)}%</span>
        `;
        
        const progressBar = document.createElement('div');
        progressBar.className = 'file-progress-bar';
        
        const progressFill = document.createElement('div');
        progressFill.className = 'file-progress-fill';
        progressFill.style.width = `${progress}%`;
        
        progressBar.appendChild(progressFill);
        progressDiv.appendChild(progressText);
        progressDiv.appendChild(progressBar);
        progressWrapper.appendChild(progressDiv);
        
        this.domElements.chatMessages.appendChild(progressWrapper);
        this.domElements.chatMessages.scrollTop = this.domElements.chatMessages.scrollHeight;
        
        // ‰øùÂ≠òËøõÂ∫¶ÂÖÉÁ¥†ÂºïÁî®
        const receiver = this.fileReceivers.get(fileId);
        if (receiver) {
            receiver.progressElement = progressWrapper;
        }
    }
    
    updateFileProgress(fileId, progress) {
        const progressWrapper = document.getElementById(`progress-${fileId}`);
        if (progressWrapper) {
            const progressFill = progressWrapper.querySelector('.file-progress-fill');
            const progressPercent = progressWrapper.querySelector('.progress-percent');
            
            if (progressFill) {
                progressFill.style.width = `${progress}%`;
            }
            if (progressPercent) {
                progressPercent.textContent = `${Math.round(progress)}%`;
            }
        }
    }
    
    removeFileProgress(fileId) {
        const progressWrapper = document.getElementById(`progress-${fileId}`);
        if (progressWrapper) {
            progressWrapper.remove();
        }
    }

    showNotification(text) {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = text;
        
        const existingNotifications = document.querySelectorAll('.notification:not(.notification-exit)');
        const offset = existingNotifications.length * 60;
        notification.style.top = `${20 + offset}px`;
        
        document.body.appendChild(notification);
        
        setTimeout(() => notification.classList.add('notification-show'), 10);
        
        setTimeout(() => {
            notification.classList.add('notification-exit');
            setTimeout(() => notification.remove(), 500);
        }, 3000);
    }

    cleanup() {
        this.closePeerConnections();
        this.roomUsers.clear();
        this.currentRoomId = null;
    }

    // ÊäΩË±°ÊñπÊ≥ïÔºåÂ≠êÁ±ªÈúÄË¶ÅÂÆûÁé∞
    handleJoinedRoom(data) {
        throw new Error('handleJoinedRoom must be implemented by subclass');
    }

    updateConnectionStatus(status) {
        throw new Error('updateConnectionStatus must be implemented by subclass');
    }
}

// ÂØºÂá∫Âü∫Á±ª
window.BaseChatMode = BaseChatMode;

// ÂàõÂª∫ÂÖ®Â±ÄÂÆû‰æã
window.modeSelector = new ModeSelector();